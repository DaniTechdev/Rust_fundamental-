// use std::any::type_name_of_val;

// use std::ops::RangeInclusive;
// use std::ops::{Range, RangeInclusive};
// use std:: mem::size_of_val;


// #[allow(unused_variables)]

fn main(){

//   let x = 5u32;

//   let y: u32 = {
//     let x_squared = x * x;
//     let x_cude = x_squared * x;

//     //This expression will be assigned to `y`
//     x_cude + x_squared + x
//   };

//   let z: ()  ={
//     //The semicolon suppressess this expression and `()` is assigned to `z`
//     2 * x;
//   };

//   println!("X is {:?}", x);
//   println!("Y is {:?}", y);
//   println!("Z is {:?}", z);


// let v:i32 = {
//     let mut x: i32 =1;
//     x +=2; //3
//     x
// };

// assert_eq!(v,3);

// println!("success!");

// let v: i32 ={
//     let x: i32 = 3;
//     x
// };

// assert!(v==3);
// println!("success");


//
// let s = sum(1,2);

// assert_eq!(s,());

// println!("success");

//Don't modify the following lines!
// let (x,y) = (1,2); //tuple destructuring
// let s: i32 = sum(x,y);

// assert_eq!(s,3);
// println!("success");


// print();


//Solve it in two ways
//Don't let `println !` works

// never_return();

// println!("Failed");


println!("success");
}


// fn get_option(tp:u8)-> Option<i32>{ //match is like switch statement
//  match tp {
//      1=> {
//         //Todo
//      }
//      _ =>{
//         //Todo
//      };

//      //Rather than returnng a None, we use diverging function instead

//      never_return_fn()
//  }
// }

// fn never_return_fn()-> !{
//     panic!();
// }

// fn never_return() -> ! {
//     //Implements this function, don't modify the fn signature
//     panic!()
// }

// fn print()-> (){ //implicity the compiler wil
//     println!("success");
// }

// fn sum(x:i32,y:i32)-> i32 { //this returns i32 type
//     x+y
// }

// fn sum(x:i32, y:i32)-> (){ //this returns unit type
//     x+y;
// }


// fn sum(x:i32, y:i32)-> i32{ ////this returns i32 type
//     x+y
// }


